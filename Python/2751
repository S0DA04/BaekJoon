#O(nlogn)
#내장함수
N = int(input());
list = [] ;
for i in range(N):
  list.append(int(input()))

list.sort()

for l in list:
  print(l)
  

#병합정렬 - 기본ver
N = int(input());
list = [] ;
for i in range(N):
  list.append([int(input())]);

sorted = []

while len(list)> 1:
  sorted = []
  length = len(list)
  divided = int(length/2)
  if length%2 == 1:
    for i in range(divided+1):
      sorted.append([])
    sorted[divided] = list[length-1]
  else : 
    for i in range(divided):
      sorted.append([])
  for j in range(divided):
    #list[2*j] 하고 list[2*j+1] 비교
    A = 0;
    B = 0;
    k = 2*j
    while A < len(list[k]) or B < len(list[k+1]):
      try:
        if list[k][A] < list[k+1][B]:
          sorted[j].append(list[k][A]);
          A += 1; 
        else:
          sorted[j].append(list[k+1][B]);
          B += 1;
      except:
        if A == len(list[k]):
          sorted[j].append(list[k+1][B]);
          B += 1;
        else:
          sorted[j].append(list[k][A]);
          A += 1;
  list = sorted;
for l in list[0]:
  print(l);


#병합정렬 - 재귀함수ver 
N = int(input());
list = [] ;
for i in range(N):
  list.append(int(input()));

def merge_sort(l):
  if len(l) == 1:
    return l
  mid = int(len(l)/2);
  left = merge_sort(l[:mid]);
  right= merge_sort(l[mid:]);
  A = 0;
  B = 0; 
  l = []
  while A < len(left) and B < len(right):
    if left[A] < right[B]:
      l.append(left[A]);
      A += 1
    else:
      l.append(right[B]);
      B += 1;
  if A == len(left):
    while B < len(right):
      l.append(right[B]);
      B += 1;
  else:
    while A < len(left):
      l.append(left[A]);
      A += 1;
  return l;

for _ in merge_sort(list):
  print(_)


#힙 정렬(시간초과 - 삽입정렬 섞어봐야겠음 :3)
N = int(input());
list = [] ;
sorted=[];

for i in range(N):
  list.append(int(input()));

def heap(list, k):
  try:
    if list[k] > list[2*k+1]:
      A = list[k];
      list[k] = list[2*k+1];
      list[2*k+1] =A;
      if k%2 == 1:
        if (k-1)/2 >= 0:
          list= heap(list, int((k-1)/2));
      else:
        if (k-2)/2 >= 0:
          list= heap(list, int((k-2)/2));  
  except:
    return list;
  try:
    if list[k] > list[2*k+2]:
      A = list[k];
      list[k] = list[2*k+2];
      list[2*k+2] =A;
      if k%2 == 1:
        if (k-1)/2 >= 0:
          list= heap(list, int((k-1)/2));
      else:
        if (k-2)/2 >= 0:
          list= heap(list, int((k-2)/2));
  except:
    return list;
  return list;

while len(list) > 0:
  for k in range(len(list)):
    list = heap(list, k);
  sorted.append(list[0]);
  list[0] = list[len(list)-1];
  del list[len(list)-1];

for j in sorted:
  print(j);
  
  
#힙 정렬(와 힙정렬 개어렵네;;)
N = int(input());
unsorted = [] ;
sorted=[];

for i in range(N):
  unsorted.append(int(input()));

def heap(list):
  n = len(list);
  #최대힙을 계산하는 부분이다. 자식노드들은 계산 할필요가 없기 때문에 n//2-1에서부터 0까지 역순으로 계산을 진행하면된다.
  #첫번째 사이클
  for i in range(n//2-1,-1,-1):
    heapify(list,i,n);

  #오름차순으로 정렬
  #2 ~사이클
  for i in range(n-1,0,-1):
    list[0], list[i] = list[i], list[0];#자리를 바꿔줌으로서 젤 큰 값을 맨 뒤로 보내주게 된다
    heapify(list, 0, i); # 맨 뒤로 보낸 값 빼고 다시 max heap으로 바꿔준다.
    
  return list;

#리스트를 Max Heap으로 바꾸는 함수. (Max Heap이란, 부모노드가 자식노드보다 큰값을 가지게 정렬된 이진트리를 말하는듯?)
def heapify(list,index,heapsize):
  largest = index;
  Left_index = 2* index+1; #왼쪽 노드 연산 식
  Right_index = 2*index+2; #오른쪽 노드 연산 식
  #왼쪽 노드가 존재하는 지 확인, 왼쪽노드의 값이 부모노드의 값보다 큰지 확인하고, 더 크다면 노드의 인덱스를 저장
  if Left_index < heapsize and list[Left_index] > list[largest]:
      largest = Left_index;

  #오른쪽 노드 계산, largest는 왼쪽노드의 값일수도 있고, 부모노드의 것일 수도 있다.
  if Right_index < heapsize and list[Right_index] > list[largest]:
      largest = Right_index;

  #가장 큰값이 부모노드가 아니라면 자식노드중 가장 큰 값을 지니는 노드의 값과 체인지한다.
  if largest != index:
      list[largest], list[index] = list[index], list[largest];
      heapify(list, largest, heapsize);

sorted = heap(unsorted);
for l in sorted:
  print(l);
#도저히 혼자서 못짜겠어서 부분부분 긁어오며 짬
#https://wonnyhouse.tistory.com/m/217


#퀵정렬(메모리 초과/ 퀵정렬의 장점을 하나도 못살림;;)
N = int(input());
sorted = []
Unsorted = [] ;
for i in range(N):
  Unsorted.append(int(input()))

def quick_sort(Unsorted):
  Pivot = Unsorted[0];
  Left = [];
  Right = [];
  for i in Unsorted[1:]:
    if i < Pivot:
      Left.append(i);
    else:
      Right.append(i);
  if len(Left) > 1:
    Left = quick_sort(Left);
  if len(Right) > 1: 
    Right = quick_sort(Right);
  A = []
  A.append(Pivot);
  return Left + A + Right; 

Sorted = quick_sort(Unsorted);
for i in Sorted:
  print(i);
  
  
#퀵정렬 (이것도 어렵네.... 재귀함수...아직도 부족하구나...)

#재귀함수 깊이 설정 코드
import sys
sys.setrecursionlimit(100000)

N = int(input());
Unsorted = [] ;
for i in range(N):
  Unsorted.append(int(input()))

def quick_sort(Unsorted,a,b):
  Pivot = Unsorted[a];
  Left = a;
  Right = b;
  while Left < Right:
    while Pivot < Unsorted[Right] and Left < Right:
      Right -= 1;
    if Left != Right:
      Unsorted[Left] = Unsorted[Right];
    while Pivot  > Unsorted[Left] and Left < Right:
      Left += 1;
    if Left != Right:
      Unsorted[Right] = Unsorted[Left];
  Unsorted[Left] = Pivot;
  Pivot = Left;
  if a < Pivot:
    quick_sort(Unsorted, a, Pivot-1);
  if b > Pivot:
    quick_sort(Unsorted, Pivot+1, b)

quick_sort(Unsorted, 0, N-1)
Sorted = Unsorted;
for i in Sorted:
  print(i); 

#참고한 코드 https://butter-shower.tistory.com/17https://butter-shower.tistory.com/17
#퀵정렬은 생각보다 효율이 좋지 않은 코드 최악의 경우 O(n^2)를 가져 평균인 O(nlogn)과 다른 시간 복잡도를 지닐수도 있음 그래서 안됌;; 
